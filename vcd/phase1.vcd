$date
	Fri May 21 17:22:30 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_bench $end
$var reg 1 ! clk $end
$scope module duv $end
$var wire 1 ! clk $end
$var wire 1 " z_flag $end
$var wire 32 # out_shift [31:0] $end
$var wire 32 $ out_adder2 [31:0] $end
$var wire 32 % out_adder1 [31:0] $end
$var wire 5 & mux_bank [4:0] $end
$var wire 32 ' mux_alu [31:0] $end
$var wire 32 ( mem_out [31:0] $end
$var wire 32 ) ext [31:0] $end
$var wire 32 * alu_out [31:0] $end
$var wire 3 + alu_c [2:0] $end
$var wire 32 , WriteData [31:0] $end
$var wire 1 - RegWrite $end
$var wire 1 . RegDst $end
$var wire 32 / RD2 [31:0] $end
$var wire 32 0 RD1 [31:0] $end
$var wire 1 1 MemWrite $end
$var wire 1 2 MemToReg $end
$var wire 1 3 MemRead $end
$var wire 32 4 INS_PC [31:0] $end
$var wire 32 5 INS_ADDR [31:0] $end
$var wire 32 6 INS [31:0] $end
$var wire 1 7 Branch $end
$var wire 1 8 ALUSrc $end
$var wire 3 9 ALUOp [2:0] $end
$scope module a_control $end
$var wire 6 : FUNCTION [5:0] $end
$var wire 9 ; control [8:0] $end
$var wire 3 < ALUOP [2:0] $end
$var reg 3 = OP [2:0] $end
$upscope $end
$scope module bank $end
$var wire 5 > AR1 [4:0] $end
$var wire 5 ? AR2 [4:0] $end
$var wire 1 - REG_WRITE $end
$var wire 32 @ DIN [31:0] $end
$var wire 5 A AW [4:0] $end
$var reg 32 B DR1 [31:0] $end
$var reg 32 C DR2 [31:0] $end
$var integer 32 D i [31:0] $end
$upscope $end
$scope module extensor $end
$var wire 16 E IN [15:0] $end
$var wire 32 F OUT [31:0] $end
$upscope $end
$scope module fetch_0 $end
$var wire 1 ! clk $end
$var wire 32 G INS [31:0] $end
$var reg 32 H INS_OUT [31:0] $end
$upscope $end
$scope module fetch_1 $end
$var wire 32 I A [31:0] $end
$var wire 32 J B [31:0] $end
$var wire 32 K R [31:0] $end
$upscope $end
$scope module fetch_2 $end
$var wire 32 L ADDR [31:0] $end
$var reg 32 M INS [31:0] $end
$upscope $end
$scope module memory $end
$var wire 32 N DIN [31:0] $end
$var wire 1 1 en_W $end
$var wire 1 3 en_R $end
$var wire 32 O ADDR [31:0] $end
$var reg 32 P R [31:0] $end
$upscope $end
$scope module post_adder $end
$var wire 32 Q A [31:0] $end
$var wire 1 R SEL $end
$var wire 32 S B [31:0] $end
$var reg 32 T R [31:0] $end
$upscope $end
$scope module post_memory $end
$var wire 32 U A [31:0] $end
$var wire 1 2 SEL $end
$var wire 32 V B [31:0] $end
$var reg 32 W R [31:0] $end
$upscope $end
$scope module post_shift $end
$var wire 32 X A [31:0] $end
$var wire 32 Y R [31:0] $end
$var wire 32 Z B [31:0] $end
$upscope $end
$scope module pre_alu $end
$var wire 32 [ A [31:0] $end
$var wire 32 \ B [31:0] $end
$var wire 1 8 SEL $end
$var reg 32 ] R [31:0] $end
$upscope $end
$scope module pre_bank $end
$var wire 5 ^ A [4:0] $end
$var wire 5 _ B [4:0] $end
$var wire 1 . SEL $end
$var reg 5 ` R [4:0] $end
$upscope $end
$scope module s_left $end
$var wire 32 a IN [31:0] $end
$var wire 32 b OUT [31:0] $end
$upscope $end
$scope module super $end
$var wire 6 c OPCODE [5:0] $end
$var reg 3 d ALUOp [2:0] $end
$var reg 1 8 ALUSrc $end
$var reg 1 7 Branch $end
$var reg 1 3 MemRead $end
$var reg 1 2 MemToReg $end
$var reg 1 1 MemWrite $end
$var reg 1 . RegDst $end
$var reg 1 - RegWrite $end
$upscope $end
$scope module super_alu $end
$var wire 32 e A [31:0] $end
$var wire 32 f B [31:0] $end
$var wire 3 g SEL [2:0] $end
$var reg 32 h R [31:0] $end
$var reg 1 " ZF $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx h
bx g
bx f
bx e
bx d
bx c
bx00 b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx00 Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
xR
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
b100 J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
x8
x7
bx 6
bx 5
bx 4
x3
x2
x1
bx 0
bx /
x.
x-
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx00 #
x"
0!
$end
#10
1!
#20
0!
#30
1!
#40
0!
#50
1!
#60
0!
#70
1!
#80
0!
#90
1!
#100
0!
#110
1!
#120
0!
#130
1!
#140
0!
#150
1!
#160
0!
