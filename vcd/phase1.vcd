$date
	Fri May 28 00:32:21 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_bench $end
$var reg 1 ! clk $end
$scope module duv $end
$var wire 1 ! clk $end
$var wire 1 " z_flag $end
$var wire 32 # out_shift [31:0] $end
$var wire 1 $ out_and $end
$var wire 32 % out_adder2 [31:0] $end
$var wire 32 & out_adder1 [31:0] $end
$var wire 5 ' mux_bank [4:0] $end
$var wire 32 ( mux_alu [31:0] $end
$var wire 32 ) mem_out [31:0] $end
$var wire 32 * ext [31:0] $end
$var wire 32 + alu_out [31:0] $end
$var wire 3 , alu_c [2:0] $end
$var wire 32 - WriteData [31:0] $end
$var wire 1 . RegWrite $end
$var wire 1 / RegDst $end
$var wire 32 0 RD2 [31:0] $end
$var wire 32 1 RD1 [31:0] $end
$var wire 1 2 MemWrite $end
$var wire 1 3 MemToReg $end
$var wire 1 4 MemRead $end
$var wire 32 5 INS_PC [31:0] $end
$var wire 32 6 INS_ADDR [31:0] $end
$var wire 32 7 INS [31:0] $end
$var wire 1 8 Branch $end
$var wire 1 9 ALUSrc $end
$var wire 3 : ALUOp [2:0] $end
$scope module a_control $end
$var wire 6 ; FUNCTION [5:0] $end
$var wire 9 < control [8:0] $end
$var wire 3 = ALUOP [2:0] $end
$var reg 3 > OP [2:0] $end
$upscope $end
$scope module adder_ins $end
$var wire 32 ? B [31:0] $end
$var wire 32 @ R [31:0] $end
$var wire 32 A A [31:0] $end
$upscope $end
$scope module and_branch $end
$var wire 1 $ R $end
$var wire 1 " B $end
$var wire 1 8 A $end
$upscope $end
$scope module bank $end
$var wire 5 B AR1 [4:0] $end
$var wire 5 C AR2 [4:0] $end
$var wire 1 . REG_WRITE $end
$var wire 32 D DIN [31:0] $end
$var wire 5 E AW [4:0] $end
$var reg 32 F DR1 [31:0] $end
$var reg 32 G DR2 [31:0] $end
$var integer 32 H i [31:0] $end
$upscope $end
$scope module extensor $end
$var wire 16 I IN [15:0] $end
$var wire 32 J OUT [31:0] $end
$upscope $end
$scope module instructions $end
$var wire 32 K ADDR [31:0] $end
$var reg 32 L INS [31:0] $end
$upscope $end
$scope module memory $end
$var wire 32 M DIN [31:0] $end
$var wire 1 2 en_W $end
$var wire 1 4 en_R $end
$var wire 32 N ADDR [31:0] $end
$var reg 32 O R [31:0] $end
$upscope $end
$scope module pcontrol $end
$var wire 1 ! clk $end
$var wire 32 P INS [31:0] $end
$var reg 32 Q INS_OUT [31:0] $end
$upscope $end
$scope module post_adder $end
$var wire 32 R A [31:0] $end
$var wire 1 $ SEL $end
$var wire 32 S B [31:0] $end
$var reg 32 T R [31:0] $end
$upscope $end
$scope module post_memory $end
$var wire 32 U B [31:0] $end
$var wire 1 3 SEL $end
$var wire 32 V A [31:0] $end
$var reg 32 W R [31:0] $end
$upscope $end
$scope module post_shift $end
$var wire 32 X A [31:0] $end
$var wire 32 Y R [31:0] $end
$var wire 32 Z B [31:0] $end
$upscope $end
$scope module pre_alu $end
$var wire 32 [ A [31:0] $end
$var wire 32 \ B [31:0] $end
$var wire 1 9 SEL $end
$var reg 32 ] R [31:0] $end
$upscope $end
$scope module pre_bank $end
$var wire 5 ^ A [4:0] $end
$var wire 5 _ B [4:0] $end
$var wire 1 / SEL $end
$var reg 5 ` R [4:0] $end
$upscope $end
$scope module s_left $end
$var wire 32 a IN [31:0] $end
$var wire 32 b OUT [31:0] $end
$upscope $end
$scope module super $end
$var wire 6 c OPCODE [5:0] $end
$var reg 3 d ALUOp [2:0] $end
$var reg 1 9 ALUSrc $end
$var reg 1 8 Branch $end
$var reg 1 4 MemRead $end
$var reg 1 3 MemToReg $end
$var reg 1 2 MemWrite $end
$var reg 1 / RegDst $end
$var reg 1 . RegWrite $end
$upscope $end
$scope module super_alu $end
$var wire 32 e A [31:0] $end
$var wire 32 f B [31:0] $end
$var wire 3 g SEL [2:0] $end
$var reg 32 h R [31:0] $end
$var reg 1 " ZF $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11 h
b0 g
b10 f
b1 e
b10 d
b0 c
b11111111111111101000000010000000 b
b11111111111111111010000000100000 a
b10100 `
b10100 _
b10 ^
b10 ]
b11111111111111111010000000100000 \
b10 [
b11111111111111101000000010000000 Z
b11111111111111101000000010000100 Y
b100 X
b11 W
b11 V
bx U
b100 T
b11111111111111101000000010000100 S
b100 R
b0 Q
b100 P
bx O
b11 N
b10 M
b1000101010000000100000 L
b0 K
b11111111111111111010000000100000 J
b1010000000100000 I
bx H
b10 G
b1 F
b10100 E
b11 D
b10 C
b1 B
b0 A
b100 @
b100 ?
b0 >
b10 =
b10100000 <
b100000 ;
b10 :
09
08
b1000101010000000100000 7
b100 6
b0 5
04
03
02
b1 1
b10 0
1/
1.
b11 -
b0 ,
b11 +
b11111111111111111010000000100000 *
bx )
b10 (
b10100 '
b100 &
b11111111111111101000000010000100 %
0$
b11111111111111101000000010000000 #
0"
x!
$end
#10
0!
#20
b1 -
b1 D
b1 W
b1 +
b1 N
b1 V
b1 h
b1 ,
b1 >
b1 g
b11111111111111101010000010001000 #
b11111111111111101010000010001000 Z
b11111111111111101010000010001000 b
b100 (
b100 ]
b100 f
b100 0
b100 G
b100 M
b100 [
b101 1
b101 F
b101 e
b10101 '
b10101 E
b10101 `
b10100010 <
b100010 ;
b11111111111111111010100000100010 *
b11111111111111111010100000100010 J
b11111111111111111010100000100010 \
b11111111111111111010100000100010 a
b1010100000100010 I
b100 C
b101 B
b10101 _
b100 ^
b1000 6
b1000 P
b1000 T
b101001001010100000100010 7
b101001001010100000100010 L
b11111111111111101010000010010000 %
b11111111111111101010000010010000 S
b11111111111111101010000010010000 Y
b1000 &
b1000 @
b1000 R
b1000 X
b100 5
b100 A
b100 K
b100 Q
1!
#30
0!
#40
1"
b0 -
b0 D
b0 W
b0 +
b0 N
b0 V
b0 h
b10 ,
b10 >
b10 g
b11111111111111110000000010010000 #
b11111111111111110000000010010000 Z
b11111111111111110000000010010000 b
b1000 1
b1000 F
b1000 e
b11000 '
b11000 E
b11000 `
b10100100 <
b100100 ;
b11111111111111111100000000100100 *
b11111111111111111100000000100100 J
b11111111111111111100000000100100 \
b11111111111111111100000000100100 a
b1100000000100100 I
b1000 B
b11000 _
b1100 6
b1100 P
b1100 T
b1000001001100000000100100 7
b1000001001100000000100100 L
b11111111111111110000000010011100 %
b11111111111111110000000010011100 S
b11111111111111110000000010011100 Y
b1100 &
b1100 @
b1100 R
b1100 X
b1000 5
b1000 A
b1000 K
b1000 Q
1!
#50
0!
#60
0"
b1010 -
b1010 D
b1010 W
b1010 +
b1010 N
b1010 V
b1010 h
b11 ,
b11 >
b11 g
b11111111111111110010000010010100 #
b11111111111111110010000010010100 Z
b11111111111111110010000010010100 b
b1010 (
b1010 ]
b1010 f
b1010 0
b1010 G
b1010 M
b1010 [
b1010 1
b1010 F
b1010 e
b11001 '
b11001 E
b11001 `
b10100101 <
b100101 ;
b11111111111111111100100000100101 *
b11111111111111111100100000100101 J
b11111111111111111100100000100101 \
b11111111111111111100100000100101 a
b1100100000100101 I
b1010 C
b1010 B
b11001 _
b1010 ^
b10000 6
b10000 P
b10000 T
b1010010101100100000100101 7
b1010010101100100000100101 L
b11111111111111110010000010100100 %
b11111111111111110010000010100100 S
b11111111111111110010000010100100 Y
b10000 &
b10000 @
b10000 R
b10000 X
b1100 5
b1100 A
b1100 K
b1100 Q
1!
#70
0!
#80
b1 -
b1 D
b1 W
b1 +
b1 N
b1 V
b1 h
b100 ,
b100 >
b100 g
b11111111111111110100000010101000 #
b11111111111111110100000010101000 Z
b11111111111111110100000010101000 b
b101 1
b101 F
b101 e
b11010 '
b11010 E
b11010 `
b10101010 <
b101010 ;
b11111111111111111101000000101010 *
b11111111111111111101000000101010 J
b11111111111111111101000000101010 \
b11111111111111111101000000101010 a
b1101000000101010 I
b101 B
b11010 _
b10100 6
b10100 P
b10100 T
b101010101101000000101010 7
b101010101101000000101010 L
b11111111111111110100000010111100 %
b11111111111111110100000010111100 S
b11111111111111110100000010111100 Y
b10100 &
b10100 @
b10100 R
b10100 X
b10000 5
b10000 A
b10000 K
b10000 Q
1!
#90
0!
#100
1"
b0 -
b0 D
b0 W
b0 +
b0 N
b0 V
b0 h
b111 ,
b111 >
b111 g
b0 #
b0 Z
b0 b
b0 (
b0 ]
b0 f
b100000 H
b0 0
b0 G
b0 M
b0 [
b0 1
b0 F
b0 e
b0 '
b0 E
b0 `
b10000000 <
b0 ;
b0 *
b0 J
b0 \
b0 a
b0 I
b0 C
b0 B
b0 _
b0 ^
b11000 6
b11000 P
b11000 T
b0 7
b0 L
b11000 %
b11000 S
b11000 Y
b11000 &
b11000 @
b11000 R
b11000 X
b10100 5
b10100 A
b10100 K
b10100 Q
1!
#110
0!
#120
x"
bx +
bx N
bx V
bx h
bx -
bx D
bx W
x$
bx ,
bx >
bx g
bx00 #
bx00 Z
bx00 b
bx (
bx ]
bx f
bx 0
bx G
bx M
bx [
bx 1
bx F
bx e
bx '
bx E
bx `
x.
x9
x2
b1x :
b1x =
b1x d
x3
x4
x8
x/
b1xxxxxxx <
bx ;
bx *
bx J
bx \
bx a
bx I
bx C
bx B
bx _
bx ^
bx c
bx 6
bx P
bx T
bx 7
bx L
bx %
bx S
bx Y
b11100 &
b11100 @
b11100 R
b11100 X
b11000 5
b11000 A
b11000 K
b11000 Q
1!
