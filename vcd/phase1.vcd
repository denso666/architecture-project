$date
	Fri May 28 09:13:59 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_bench $end
$var reg 1 ! clk $end
$scope module duv $end
$var wire 1 ! clk $end
$var wire 1 " z_flag $end
$var wire 32 # out_shift [31:0] $end
$var wire 1 $ out_and $end
$var wire 32 % out_adder2 [31:0] $end
$var wire 32 & out_adder1 [31:0] $end
$var wire 5 ' mux_bank [4:0] $end
$var wire 32 ( mux_alu [31:0] $end
$var wire 32 ) mem_out [31:0] $end
$var wire 32 * ext [31:0] $end
$var wire 32 + alu_out [31:0] $end
$var wire 3 , alu_c [2:0] $end
$var wire 32 - WriteData [31:0] $end
$var wire 1 . RegWrite $end
$var wire 1 / RegDst $end
$var wire 32 0 RD2 [31:0] $end
$var wire 32 1 RD1 [31:0] $end
$var wire 1 2 MemWrite $end
$var wire 1 3 MemToReg $end
$var wire 1 4 MemRead $end
$var wire 32 5 INS_PC [31:0] $end
$var wire 32 6 INS_ADDR [31:0] $end
$var wire 32 7 INS [31:0] $end
$var wire 1 8 Branch $end
$var wire 1 9 ALUSrc $end
$var wire 3 : ALUOp [2:0] $end
$scope module a_control $end
$var wire 6 ; FUNCTION [5:0] $end
$var wire 9 < control [8:0] $end
$var wire 3 = ALUOP [2:0] $end
$var reg 3 > OP [2:0] $end
$upscope $end
$scope module adder_ins $end
$var wire 32 ? B [31:0] $end
$var wire 32 @ R [31:0] $end
$var wire 32 A A [31:0] $end
$upscope $end
$scope module and_branch $end
$var wire 1 $ R $end
$var wire 1 " B $end
$var wire 1 8 A $end
$upscope $end
$scope module bank $end
$var wire 5 B AR1 [4:0] $end
$var wire 5 C AR2 [4:0] $end
$var wire 1 . REG_WRITE $end
$var wire 32 D DIN [31:0] $end
$var wire 5 E AW [4:0] $end
$var reg 32 F DR1 [31:0] $end
$var reg 32 G DR2 [31:0] $end
$upscope $end
$scope module extensor $end
$var wire 16 H IN [15:0] $end
$var wire 32 I OUT [31:0] $end
$upscope $end
$scope module instructions $end
$var wire 32 J ADDR [31:0] $end
$var reg 32 K INS [31:0] $end
$upscope $end
$scope module memory $end
$var wire 32 L DIN [31:0] $end
$var wire 1 2 en_W $end
$var wire 1 4 en_R $end
$var wire 32 M ADDR [31:0] $end
$var reg 32 N R [31:0] $end
$upscope $end
$scope module pcontrol $end
$var wire 1 ! clk $end
$var wire 32 O INS [31:0] $end
$var reg 32 P INS_OUT [31:0] $end
$upscope $end
$scope module post_adder $end
$var wire 32 Q A [31:0] $end
$var wire 1 $ SEL $end
$var wire 32 R B [31:0] $end
$var reg 32 S R [31:0] $end
$upscope $end
$scope module post_memory $end
$var wire 32 T B [31:0] $end
$var wire 1 3 SEL $end
$var wire 32 U A [31:0] $end
$var reg 32 V R [31:0] $end
$upscope $end
$scope module post_shift $end
$var wire 32 W A [31:0] $end
$var wire 32 X R [31:0] $end
$var wire 32 Y B [31:0] $end
$upscope $end
$scope module pre_alu $end
$var wire 32 Z A [31:0] $end
$var wire 32 [ B [31:0] $end
$var wire 1 9 SEL $end
$var reg 32 \ R [31:0] $end
$upscope $end
$scope module pre_bank $end
$var wire 5 ] A [4:0] $end
$var wire 5 ^ B [4:0] $end
$var wire 1 / SEL $end
$var reg 5 _ R [4:0] $end
$upscope $end
$scope module s_left $end
$var wire 32 ` IN [31:0] $end
$var wire 32 a OUT [31:0] $end
$upscope $end
$scope module super $end
$var wire 6 b OPCODE [5:0] $end
$var reg 3 c ALUOp [2:0] $end
$var reg 1 9 ALUSrc $end
$var reg 1 8 Branch $end
$var reg 1 4 MemRead $end
$var reg 1 3 MemToReg $end
$var reg 1 2 MemWrite $end
$var reg 1 / RegDst $end
$var reg 1 . RegWrite $end
$upscope $end
$scope module super_alu $end
$var wire 32 d A [31:0] $end
$var wire 32 e B [31:0] $end
$var wire 3 f SEL [2:0] $end
$var reg 32 g R [31:0] $end
$var reg 1 " ZF $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11 g
b0 f
b10 e
b1 d
b10 c
b0 b
b11111111111111101000000010000000 a
b11111111111111111010000000100000 `
b10100 _
b10100 ^
b10 ]
b10 \
b11111111111111111010000000100000 [
b10 Z
b11111111111111101000000010000000 Y
b11111111111111101000000010000100 X
b100 W
b11 V
b11 U
bx T
b100 S
b11111111111111101000000010000100 R
b100 Q
b0 P
b100 O
bx N
b11 M
b10 L
b1000101010000000100000 K
b0 J
b11111111111111111010000000100000 I
b1010000000100000 H
b10 G
b1 F
b10100 E
b11 D
b10 C
b1 B
b0 A
b100 @
b100 ?
b0 >
b10 =
b10100000 <
b100000 ;
b10 :
09
08
b1000101010000000100000 7
b100 6
b0 5
04
03
02
b1 1
b10 0
1/
1.
b11 -
b0 ,
b11 +
b11111111111111111010000000100000 *
bx )
b10 (
b10100 '
b100 &
b11111111111111101000000010000100 %
0$
b11111111111111101000000010000000 #
0"
x!
$end
#10
0!
#20
b1 -
b1 D
b1 V
b1 +
b1 M
b1 U
b1 g
b1 ,
b1 >
b1 f
b11111111111111101010000010001000 #
b11111111111111101010000010001000 Y
b11111111111111101010000010001000 a
b100 (
b100 \
b100 e
b100 0
b100 G
b100 L
b100 Z
b101 1
b101 F
b101 d
b10101 '
b10101 E
b10101 _
b10100010 <
b100010 ;
b11111111111111111010100000100010 *
b11111111111111111010100000100010 I
b11111111111111111010100000100010 [
b11111111111111111010100000100010 `
b1010100000100010 H
b100 C
b101 B
b10101 ^
b100 ]
b1000 6
b1000 O
b1000 S
b101001001010100000100010 7
b101001001010100000100010 K
b11111111111111101010000010010000 %
b11111111111111101010000010010000 R
b11111111111111101010000010010000 X
b1000 &
b1000 @
b1000 Q
b1000 W
b100 5
b100 A
b100 J
b100 P
1!
#30
0!
#40
1"
b0 -
b0 D
b0 V
b0 +
b0 M
b0 U
b0 g
b10 ,
b10 >
b10 f
b11111111111111110000000010010000 #
b11111111111111110000000010010000 Y
b11111111111111110000000010010000 a
b1000 1
b1000 F
b1000 d
b11000 '
b11000 E
b11000 _
b10100100 <
b100100 ;
b11111111111111111100000000100100 *
b11111111111111111100000000100100 I
b11111111111111111100000000100100 [
b11111111111111111100000000100100 `
b1100000000100100 H
b1000 B
b11000 ^
b1100 6
b1100 O
b1100 S
b1000001001100000000100100 7
b1000001001100000000100100 K
b11111111111111110000000010011100 %
b11111111111111110000000010011100 R
b11111111111111110000000010011100 X
b1100 &
b1100 @
b1100 Q
b1100 W
b1000 5
b1000 A
b1000 J
b1000 P
1!
#50
0!
#60
0"
b1010 -
b1010 D
b1010 V
b1010 +
b1010 M
b1010 U
b1010 g
b11 ,
b11 >
b11 f
b11111111111111110010000010010100 #
b11111111111111110010000010010100 Y
b11111111111111110010000010010100 a
b1010 (
b1010 \
b1010 e
b1010 0
b1010 G
b1010 L
b1010 Z
b1010 1
b1010 F
b1010 d
b11001 '
b11001 E
b11001 _
b10100101 <
b100101 ;
b11111111111111111100100000100101 *
b11111111111111111100100000100101 I
b11111111111111111100100000100101 [
b11111111111111111100100000100101 `
b1100100000100101 H
b1010 C
b1010 B
b11001 ^
b1010 ]
b10000 6
b10000 O
b10000 S
b1010010101100100000100101 7
b1010010101100100000100101 K
b11111111111111110010000010100100 %
b11111111111111110010000010100100 R
b11111111111111110010000010100100 X
b10000 &
b10000 @
b10000 Q
b10000 W
b1100 5
b1100 A
b1100 J
b1100 P
1!
#70
0!
#80
b1 -
b1 D
b1 V
b1 +
b1 M
b1 U
b1 g
b100 ,
b100 >
b100 f
b11111111111111110100000010101000 #
b11111111111111110100000010101000 Y
b11111111111111110100000010101000 a
b101 1
b101 F
b101 d
b11010 '
b11010 E
b11010 _
b10101010 <
b101010 ;
b11111111111111111101000000101010 *
b11111111111111111101000000101010 I
b11111111111111111101000000101010 [
b11111111111111111101000000101010 `
b1101000000101010 H
b101 B
b11010 ^
b10100 6
b10100 O
b10100 S
b101010101101000000101010 7
b101010101101000000101010 K
b11111111111111110100000010111100 %
b11111111111111110100000010111100 R
b11111111111111110100000010111100 X
b10100 &
b10100 @
b10100 Q
b10100 W
b10000 5
b10000 A
b10000 J
b10000 P
1!
#90
0!
#100
1"
b0 -
b0 D
b0 V
b0 +
b0 M
b0 U
b0 g
b111 ,
b111 >
b111 f
b0 #
b0 Y
b0 a
b0 (
b0 \
b0 e
b0 0
b0 G
b0 L
b0 Z
b0 1
b0 F
b0 d
b0 '
b0 E
b0 _
b10000000 <
b0 ;
b0 *
b0 I
b0 [
b0 `
b0 H
b0 C
b0 B
b0 ^
b0 ]
b11000 6
b11000 O
b11000 S
b0 7
b0 K
b11000 %
b11000 R
b11000 X
b11000 &
b11000 @
b11000 Q
b11000 W
b10100 5
b10100 A
b10100 J
b10100 P
1!
#110
0!
#120
x"
bx +
bx M
bx U
bx g
bx -
bx D
bx V
x$
bx ,
bx >
bx f
bx00 #
bx00 Y
bx00 a
bx (
bx \
bx e
bx 0
bx G
bx L
bx Z
bx 1
bx F
bx d
bx '
bx E
bx _
x.
x9
x2
b1x :
b1x =
b1x c
x3
x4
x8
x/
b1xxxxxxx <
bx ;
bx *
bx I
bx [
bx `
bx H
bx C
bx B
bx ^
bx ]
bx b
bx 6
bx O
bx S
bx 7
bx K
bx %
bx R
bx X
b11100 &
b11100 @
b11100 Q
b11100 W
b11000 5
b11000 A
b11000 J
b11000 P
1!
